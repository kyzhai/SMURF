open Ast
open Printf
open Util
open Values
open Random

exception Output_error of string
let output_error msg = raise (Output_error msg)

let default_velocity = 90

(* Write the head of each smurf file, returns the number of tracks *)
(* write_head : out_channel -> value -> int *)
let write_head oc value = 
    let header = "***** Generated by SMURF *****" in 
    let number_of_track = (match value with
          VList(lst) -> (
              try 
                  match List.hd lst with 
                    VSystem(_) -> List.length lst (* list of system *)
                  | _ -> 1
              with 
                Failure _ -> 0 (* Empty list *)
              )
        | _ -> 1) in 
    let resolution = 4 in
    let () = fprintf oc "%s\n" header in 
    let () = fprintf oc "number of trace: %d\n" number_of_track in 
    let () = fprintf oc "Time Resolution (pulses per quarter note),%d,\n" resolution in 
    let () = Random.init 0 in
    let () = for i=1 to number_of_track 
        do fprintf oc "track %d,%d," i 48 
        done in
    let () = fprintf oc "\n" in
    let () = for i=1 to number_of_track 
        do fprintf oc "Tick, Note (0-127), Velocity (0-127), " 
        done in 
    let () = fprintf oc "\n" in number_of_track
    

(* get the number of ticks of a beat *)
(* VBeat -> Int *)
let ticks_of_beat = function
      VBeat(VInt(i1),i2) -> 
(      print_string("Beat has components " ^ (string_of_int i1) ^ " and " ^ (string_of_int i2) ^ "\n"));
      (int_of_float 
          ((16.0/.(float_of_int i1)) +.
              ((match i2 with 
                 0 -> 0.0
               | 1 -> (8.0/.(float_of_int i1))
               | 2 -> (4.0/.(float_of_int i1))
               | 3 -> (2.0/.(float_of_int i1))
               | 4 -> (float_of_int i1) 
               | _ -> output_error ("Error in ticks_of_beat: Not valid numbers"))
                       )))
    | _ -> output_error ("Error in ticks_of_beat: Not a beat")

(* figure how many ticks are there in the output, so that an array with suitable size can be generated *)
(* value -> Int *)
let rec ticks_of_output value = 
    match value with
      VNote(pc,reg,bt) -> (print_string ("Calculating ticks gives us a total of " ^ (string_of_int (ticks_of_beat bt)) ^ "\n")); 
                          ticks_of_beat bt
    | VChord(nlst) -> List.fold_left (fun acc ch -> acc + ticks_of_output ch) 0 nlst
    | VSystem(slst) -> List.fold_left (fun acc ch -> acc + ticks_of_output ch) 0 slst 
    | VList(lst) -> List.fold_left (fun m sys -> let tick = ticks_of_output sys in 
            if m < tick then tick else m) 0 lst
    | _ -> output_error ("Error in ticks_of_output")


(* Write a note into an array, return the next postion to be writen, and the next tick to begin with *)
(* Value -> Array -> Int -> Int -> Int -> (Int, Int, Int) *)
let rec write_to_array value arr ix iy tic = 
    (match value with
    | VNote(VInt(p),VInt(r),bt) -> let nt = ticks_of_beat bt in 
        let note = (match p with 
              -1 -> -1
            | _ -> p+12*(r+3)) in (
            arr.(ix).(iy) <- tic;                   (* tick *)
            arr.(ix).(iy+1) <- note;                  (* note *)
            arr.(ix).(iy+2) <- default_velocity;      (* velocity *)
            arr.(ix+1).(iy) <- tic+nt;
            arr.(ix+1).(iy+1) <- note;
            arr.(ix+1).(iy+2) <- 0;
            ix+nt,iy,tic+nt)
    (* All notes in a chord should fills same set of ticks *)
    | VChord((VNote(_,_,bt)::xs) as nlst) -> 
        (let ntks = ticks_of_beat bt in
         let resx, resy, restic = 
         (List.fold_left (fun (x,y,ntic) note -> 
            let (nx,ny,ntic) = write_to_array note arr x y ntic 
            in (nx,ny,tic)) (ix,iy,tic) nlst) in resx, resy, restic+ntks)
    | VSystem(clst) -> 
        (let resx, resy, resz = 
        List.fold_left (fun (x,y,ntic) chord -> 
            let (nx,ny,ntic) = write_to_array chord arr x y ntic
            in (nx,ny,ntic)) (ix,iy,tic) clst in (0,resy+3,0))
    | VList((x::xs) as slst) -> (match x with
          VSystem(_) -> List.fold_left (fun (x,y,ntic) sys ->
                  let (nx,ny,ntic) = write_to_array sys arr x y ntic
                  in (nx,ny,ntic)) (ix,iy,tic) slst
        | _ -> output_error ("Error in write_to_array: Must be a list of systems"))
    | _ -> output_error ("Error in write_to_array: Input is not a valid value")
    )


(* Write a Chord or a System or a list of Systems to file with smurf specified format *)
(* write_to_file : string -> value -> unit *)
let write_to_file filename value = 
    let oc = open_out filename in 
    let number_of_track = write_head oc value in 
    match number_of_track with
          0 -> close_out oc; output_error ("Empty list")
        | _ -> (
    let dimx = ticks_of_output value in
    print_string ("Total number of beat: " ^ (string_of_int dimx) ^ "\n");
    let dimy = number_of_track * 3 in
    let resArr = (Array.make_matrix (dimx) (dimy) (-1)) in 
    let _ = (write_to_array value resArr 0 0 0) in 
    let () = 
    (for i=0 to dimx-1 do
        for j=0 to (number_of_track -1) do
            if resArr.(i).(3*j+1) <> (-1) then
                ignore(fprintf oc "%d,%d,%d," resArr.(i).(3*j) resArr.(i).(3*j+1) resArr.(i).(3*j+2))
            else
                ignore(fprintf oc ",,,")
        done;
        ignore(fprintf oc "\n")
    done) in ()
    ; close_out oc
    )



