\section{Syntax}

SMURF is a functional programming language loosely modeled off of Haskell. It has immutable memory, no global variables and no I/O.

\subsection{Types}

\subsubsection{Standard Types}
\begin{itemize}
\item Integer: int
\item Boolean: bool
\item Tuples: elements can have different types
\item Lists: elements must have same type
\end{itemize}

\subsubsection{Note (pc: int, beat: int, register: int)}
\begin{itemize}
\item pc (pitch class): represented by integers 0-11
  \begin{itemize}
  \item Note with pc = -1 represents a rest, used in Measure type
  \end{itemize}
\item beat: represented by powers of 2 up to 32 (assuming \Takt{4}{4} time)
\item register: represented by integers -2 to 2
  \begin{itemize}
  \item \begin{music}  \trebleclef  \end{music}  Treble Clef: notes middle C and higher represented by 0-2  
  \item \begin{music} \bassclef  \end{music}  Bass Clef: notes lower than middle C represented by negative numbers
  \end{itemize}
\end{itemize}

\subsubsection{Chord ([Note])}
\begin{itemize}
\item Type checks that all notes have same beat count
\end{itemize}

\subsubsection{Measure ([Chord])}
\begin{itemize}
\item Type check that measure has exactly 4 beats
\end{itemize}

\subsubsection{Score ([Measure])}

\subsubsection{Functions}
A function is a type whose value can be defined with an expression
\begin{itemize}
\item Function declarations must declare type (can declare general type)
\item Function declarations must be on own line
\item No explicit return
\item Pattern matching, guards, and if-then-else clauses used
  \begin{itemize}
  \item Each pattern matching pattern must be on own line
  \item Guards and if-then-else clauses do not have newline restrictions
  \end{itemize}
\end{itemize}

\begin{table} [h]
	\centering
    \begin{tabular}{ll}
    \hline\hline
    Operators & \\
    \hline\hline
       \textbackslash n & End of line: Terminates phrases \\ \hline
      + & Integer arithmetic: plus  \\ \hline
      - & Integer arithmetic: minus  \\ \hline 
      \% & Integer arithmetic: modulus, ignores negatives  \\ \hline
      = & Assignment operator \\ \hline
      \textless  & Comparison \\ \hline
      \textgreater  & Comparison \\ \hline
      \textless=  & Comparison \\ \hline
      \textgreater= & Comparison \\ \hline
       == & Boolean operator: Structural comparison  \\ \hline
       not & Boolean operator \\ \hline
       \&\& & Boolean operator \\ \hline
       \textbar\textbar & Boolean operator \\ \hline
       \textbar & Boolean operator, used with guards\\ \hline
       :: & Type specification \\ \hline
       \textendash\textgreater & Argument and function return type specification  \\ \hline
      ++ & Concatenation: concat \\ \hline
      : & Construction: cons \\ \hline
      /* */ & Multiline comments, nesting allowed \\ \hline
      // & Single-line comment \\ \hline
    \end{tabular}
\end{table}

\begin{table} [h]
	\centering
    \begin{tabular}{ll}
    \hline\hline
    Keywords & \\ 
    \hline\hline
      let & Specify values and functions  \\ \hline
      in & Allow local variable binding in expression \\ \hline
      if, then, else & Specify conditional expression, else compulsory  \\ \hline
      gen\_score & Generate musical score given Score as argument  \\ \hline
    \end{tabular}
\end{table}

