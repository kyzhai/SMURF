\section{Lessons Learned}

\subsection{Lindsay Neubauer}
We had a meeting at the same time every week that lasted between one and two hours that everyone attended. This time set aside to make real progress on project was crucial to our success. In the beginning of the semester we spent all the time discussing LRM-related topics and during the latter half of the semester it was split between discussion and coding. Often being in the same room, even for a short amount of time, while coding was helpful for figuring out the trickier aspects of our language. This was particularly helpful for me because OCaml was my first experience using a functional programming language and having access to others with more experience helped me pick it up quicker.

Another important choice we made was to designate a group leader at the beginning of this project. Our group leader was organized with tasks to discuss or complete in each meeting and helped drive the conversation in a productive way. In addition to this, we had a note taker and a person in charge of our GitHub and Latex environments. It was helpful to have �go to� people for questions and concerns that arose throughout the project.

After turning in our LRM we decided to divide each part of our language into slices. Each group member was in charge of a different aspect of our language and implemented that slice for each step of the compiler building process. This ownership of a part of the language was helpful and touching each step of the compiler was very helpful for learning. It also allowed each group member to work throughout the semester regardless of the progress made by others.

The most important learning I had from this project are understanding the functional language paradigm and knowledge on how to implement a compiler from start to finish.

\subsection{Kuangya Zhai}
First of all, the best lesson I learned from this project is: Finish early. The importance of starting early has been told by numerous previous PLT groups while the importance of finishing early has not. By finishing early I mean you should project the finishing time of the deadline of your project a bit earlier than the actual deadline to allow any exceptions. As is always said, deadline is the first productivity. Your efficiency boosts when the deadline approaches. But there exists the possibility that something unexpected happens and you are not going to be able to finished the project in the due day if your plan is to finish everything in the last day. These situation is common when you are working on a group project. Take our group as an example, we projected everything to be finished on the exact morning of the presentation while it turned out that not everything goes well as expected, so we had to presented an incomplete version which was kind of embarrassing. And the problems was solved on the exact afternoon of the presentation but we had no chance the present it again. Had we project our own deadline one day earlier, I believe the result will be much better. 

The second thing, enjoy OCaml. Few people has functional programming background before the PLT class. So it's likely that you will have a steeper learning curve when comparing with learning other programming languages. However, when you got used to the functional style, you will find it's at least as expressive and productive as imperative languages you have got used to. The thing I love the most about functional programming is its type checking system. So you will spend tons of time to get your program to compile. But once after that, your program will likely to give the correct result since most of the bugs have been captured at the compiling stage. Also, the side effect free property of functional program guarantees the robustness of your program, which is especially important when you are working on a teaming working project. OCaml is not purely functional. It also keeps several imperative features which might also be helpful and make your life much easier when comparing with Haskell, the pure functional programming language. 


\subsection{Lianne Lairmore}
The first important lesson I learned was that communication between group members is very important. Having a weekly meeting 
was very helpful for communication and helped us quickly defined what we wanted in out language. Later in the semester we still
met but our meetings were more coding instead of talking. It would have been better to spend more time talking about what we were 
doing and how far along we were. It probably would have been helpful to do some pair programming in some of the tougher part of the 
project so that when someone got stuck another person knew who to help them. 

The second important lesson I learned was that organization is important. It was important to know what each person was suppose 
to be doing at one time that way you always knew what was expected of you. Although our group might have balanced the loads more 
evenly this is hard to do not knowing either how much certain parts of the language are going to take or everyones skills. For 
example a few people in our group had considerably more experience with functional languages than the others and didn't have as 
steep a learning curve learning OCaml. 

The third important lesson I learned was to make a schedule and stick to it. Our group did half of this. We had a schedule but when 
we fell behind we didn't push hard to catch up. The first half of the semester we staid on schedule but the second half we fell 
behind and never was able to catch back up making the end a rush to finish everything. 

\subsection{Richard Townsend}
Weekly meetings are a must! While we had them and they were helpful, we mostly used them to discuss overarching language features and code in the same room.
In hindsight, it would have been effective to also use these meetings to discuss how we implemented the various features in the compiler. There were many
instances where group members had to work with someone else's code and it was not entirely clear what the original programmer's thought process was.
By going over these aspects of the compiler, a lot of time would have been saved for future coding.

It would have also been beneficial for us to assign priorities to different features of our langauge, making sure the higher priority features were
up and running before the others. In our case, function application was the highest priority (since SMURF is a functional language), but it was the last
feature to be fully implemented, leading to some stress and a less-than-ideal demo for our presentation. This problem would also have been mitigated if we assigned
some of our vertical slices to pairs of members as opposed to single members. That way, the two members would keep each other on top of the implementation and deadlines
associated with that specific language feature.

Finally, take good notes during Stephen's OCaml series of lectures. If something doesn't make sense during the lecture, talk to him or a TA about it ASAP, as you
will probably use that aspect of the language in your compiler at some point. It's imperative, especially with a huge project like a compiler, that you can read
another team member's code and understand the basic operations and processes going on.
