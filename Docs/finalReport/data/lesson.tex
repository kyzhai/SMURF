\section{Lessons Learned}

\subsection{Lindsay Neubauer}
We had a meeting at the same time every week that lasted between one and two hours that everyone attended. This time set aside to make real progress on project was crucial to our success. In the beginning of the semester we spent all the time discussing LRM-related topics and during the latter half of the semester it was split between discussion and coding. Often being in the same room, even for a short amount of time, while coding was helpful for figuring out the trickier aspects of our language. This was particularly helpful for me because OCaml was my first experience using a functional programming language and having access to others with more experience helped me pick it up quicker.
\\ \\
Another important choice we made was to designate a group leader at the beginning of this project. Our group leader was organized with tasks to discuss or complete in each meeting and helped drive the conversation in a productive way. In addition to this, we had a note taker and a person in charge of our GitHub and Latex environments. It was helpful to have “go to” people for questions and concerns that arose throughout the project.
\\ \\
After turning in our LRM we decided to divide each part of our language into slices. Each group member was in charge of a different aspect of our language and implemented that slice for each step of the compiler building process. This ownership of a part of the language was helpful and touching each step of the compiler was very helpful for learning. It also allowed each group member to work throughout the semester regardless of the progress made by others.
\\ \\
The most important learning I had from this project are understanding the functional language paradigm and knowledge on how to implement a compiler from start to finish.

\subsection{Kuangya Zhai}
First of all, the best lesson I learnt from this project is: Finish early. The importance of starting early has been told by numerous previous PLT groups while the importance of finishing early has not. By finishing early I mean you should project the finishing time of the deadline of your project a bit earlier than the actual deadline to allow any exceptions. As is always said, deadline is the first productivity. Your efficiency boosts when the deadline approaching. But there exists the possibility that something unexpected happens and you are not going to be able to finished the project in the due day if your plan is to finish everything in the last day. These situation is common when you are working on a group project. Take our group as an example, we projected everything to be finished on the exact morning of the presentation while it turned out that not everything goes well as expected, so we had to presented an incomplete version which was kind of embarrassing. And the problems was solved on the exact afternoon of the presentation but we had no chance the present it again. Had we project our own deadline one day earlier, I believe the result will be much better. 

The second thing, enjoy OCaml. Few people has functional programming background before the PLT class. So it's likely that you will have a steeper learning curve when comparing with learning other programming languages. However, when you got used to the functional style, you will find it's at least as expressive and productive as imperative languages you have got used to. The thing I love the most about functional programming is its type checking system. So you will spend tons of time to get your program to compile. But once after that, your program will likely to give the correct result since most of the bugs have been captured at the compiling stage. Also, the side effect free property of functional program guarantees the robustness of your program, which is especially important when you are working on a teaming working project. OCaml is not purely functional. It also keeps several imperative features which might also be helpful and make your life much easier when comparing with Haskell, the pure functional programming language. 
