\section{Lexical Conventions}
\subsection{A High Level Description of SMURF Programs}
A program in SMURF, at its top-most level, is a series of declarations. The declarations in SMURF include type signatures, definitions, and function declarations.

\subsection{Tokens}
In SMURF, a token is a string of one or more characters that is significant as a group.
SMURF has 6 kinds of tokens: {\it identifiers}, {\it keywords}, {\it constants},
      {\it operators},
{\it separators} and {\it newlines}.

\subsubsection{Identifiers}
\label{sec:identifiers}
An identifier consists of a letter followed by other letters, 
digits and underscores. The letters are the ascii characters {\texttt a-z}, {\texttt A-Z} and \texttt{\_}. Digits are ascii
characters {\texttt 0-9}. SMURF is case sensitive.

\begin{grammar}
<letter> $\rightarrow$ [`a'-`z' `A'-`Z'] 

<digit> $\rightarrow$ [`0'-`9'] 

<underscore> $\rightarrow$ {`_'} 

<identifier> $\rightarrow$ <letter> (<letter> | <digit> | <underscore>)*
\end{grammar}

\subsubsection{Keywords}
\label{sec:keywords}
Keywords in SMURF are words reserved by the language. Keywords in SMURF are not avaliable for
re-definition or overloading by users. Following is a list of reserved keywords in SMURF. 

\begin{table} [H]
	\centering
    \begin{tabular}{ll}
    \hline\hline
    Keywords & Descriptions \\ 
    \hline\hline
      {\texttt Bool} & Boolean data type \\ \hline
      {\texttt Int} & Integer data type \\ \hline
      {\texttt Note} & Represent musical term of note \\ \hline
      {\texttt Beat} & Represent the duration a note last \\ \hline
      {\texttt Chord} & List of several notes playing simultaneously \\ \hline
      {\texttt System} & List of several chords \\ \hline
      {\texttt True, False} & Specify boolean logic \\ \hline
      {\texttt let, in} & Allow local bindlings in expressions  \\ \hline
      {\texttt if, then, else} & Specify conditional expression, else compulsory  \\ \hline
      {\texttt otherwise} & Specify conditional expression used with guards \\ \hline 
      {\texttt random} & Generate random numbers \\ \hline
      {\texttt print} & Print information to the screen \\ \hline
      {\texttt main} & The eveluated value of which to be returned by a SMURF program\\ \hline
    \end{tabular}
\end{table}


\subsubsection{Constants}
\label{sec:constants}
In SMURF, constants are expressions with a fixed value. Integer literals and
boolean keywords are the constants of SMURF. 

\begin{grammar}
<letter> $\rightarrow$ [`a'-`z' `A'-`Z'] 

<digit> $\rightarrow$ [`0'-`9'] 

<constant> $\rightarrow$ \texttt{-}? [`1'-`9'] <digit>* | {\texttt True} | {\texttt False}
\end{grammar}

\subsubsection{Operators}
Operators in SMURF can be classified into comment operators, arithmetic operators, comparision
operators, boolean operators, list operators, declaration operators, and row operators. 

SMURF allows nested, multiline comments in addition to single line comments.
\begin{table} [H]
\centering
\begin{tabularx}{\textwidth}{lXl}
\hline\hline
Comment Operator & Description & Example \\
\hline\hline
  \texttt{/* */} & Multiline comments, nesting allowed & \texttt{/* This /* is all */ commented */} \\ \hline
  \texttt{//} & Single-line comment & \texttt{// This is a comment} \\ \hline
\end{tabularx}
\end{table}

SMURF allows addition, subtraction, and modulus on expressions that evaluate to integer literals of type \texttt{Int}. We also have addition, subtraction,
multiplication, and division on expressions that evaluate to integer literals of type \texttt{Beat}. All of these operators are infix.
The modulus operator ignores negatives e.g. \texttt{13 \% 12} is equal to \texttt{-13 \% 12} is equal to \texttt{1}. Rhythmic arithmetic is explained
in section INSERT SECTION NUMBER HERE.
\begin{table} [H]
\centering
\begin{tabularx}{\textwidth}{lXX}
\hline\hline
Arithmetic Operator & Description & Example \\
\hline\hline
  \texttt{+} & Integer Addition  & \texttt{a + 2} \\ \hline
  \texttt{-} & Integer Subtraction  & \texttt{5 - a} \\ \hline 
  \texttt{\%} & Integer Modulus, ignores negatives  & \texttt{14 \% 12} \\ \hline
  \texttt{$\wedge$+} & Rhythmic Addition & \texttt{2 $\wedge$+ 2 == 1} \\ \hline
  \texttt{$\wedge$-} & Rhythmic Subtraction & \texttt{1 $\wedge$- 2 == 2}  \\ \hline
  \texttt{$\wedge$*} & Rhythmic Augmentation & \texttt{8 $\wedge$* 4 == 2}  \\ \hline
  \texttt{$\wedge$/} & Rhythmic Diminution & \texttt{2 $\wedge$/ 8 == 16}  \\ \hline
  \texttt{.} & Increase beat duration by half for each period & \texttt{2.. == 2 $\wedge$+ 4 $\wedge$+ 8}  \\ \hline
\end{tabularx}
\end{table}

SMURF allows comparison operations between expressions that evaluate to values of type \texttt{Int} or \texttt{Beat}.
\begin{table} [H]
\centering
\begin{tabular}{lll}
\hline\hline
Comparison Operator & Description & Example \\
\hline\hline
  \texttt{<}  & Integer Less than & \texttt{if a \textless\space  5 then True else False} \\ \hline
  \texttt{>}  & Integer Greater than & \texttt{if a \textgreater\space  5 then True else False}  \\ \hline
  \texttt{<=}  & Integer Less than or equal to & \texttt{if a \textless= 5 then True else False} \\ \hline
  \texttt{>=} & Integer Greater than or equal to & \texttt{if a \textgreater= 5 then True else False} \\ \hline
  \texttt{\$<} & Rhythmic Less than & \texttt{4 \textless\space  8 == False} \\ \hline
  \texttt{\$>}  & Rhythmic Greater than &  \texttt{4 \textgreater\space  8 == True}  \\ \hline
  \texttt{\$<=} & Rhythmic Less than or equal to & \texttt{4 \textless= 4 == True} \\ \hline
  \texttt{\$>=} & Rhythmic Greater than or equal to &  \texttt{1 \textgreater= 16 == True} \\ \hline
\end{tabular}
\end{table}


SMURF allows logical negation, conjunction, and disjunction, in addition to structural comparison.
\begin{table} [H]
\centering
\begin{tabular}{lll}
\hline\hline
Boolean Operator & Description & Example \\
\hline\hline
   \texttt{==} & Structural comparison & \texttt{if a == 5 then a = True else a = False} \\ \hline
   \texttt{!} & Logical negation & \texttt{if !(a == 5) then True else False} \\ \hline
   \texttt{\&\&} & Logical conjunction & \texttt{if b \&\& c  then True else False} \\ \hline
   \texttt{\textbar\textbar} & Logical disjunction & \texttt{if b \textbar\textbar\space   c  then True else False} \\ \hline
 \end{tabular}
\end{table}

SMURF allows concatenation and construction of lists.
\begin{table} [H]
\centering
\begin{tabular}{lll}
\hline\hline
List Operator & Description & Example \\
\hline\hline
   \texttt{++} & List Concatenation & \texttt{[1,2,3] ++ [4,5,6]} (result is \texttt{[1,2,3,4,5,6]}) \\ \hline
   \texttt{:} & List Construction & \texttt{1 : [2,3,4]} (result is \texttt{[1,2,3,4]}) \\ \hline
\end{tabular}
\end{table}


SMURF provides operators to specify types of identifiers, arguments, and return values in various declarations,
as well as an operator to indicate a guard in a declaration.
\begin{table} [H]
\centering
\begin{tabularx}{\textwidth}{lXl}
\hline\hline
Declaration Operator & Description & Example \\
\hline\hline
   \texttt{::} & Type specification & \texttt{number :: Int} \\ \hline
   \texttt{->} & Argument and function return type specification
     & \texttt{isPositiveNum :: Int -> Bool}  \\ \hline
   \texttt{\textbar} & Gaurd indicator & \texttt{isSeven :: [Int] -> Bool}\\ 
	 	 && \texttt{isSeven num} \\
     && \texttt{\textbar\space (num == 7) = True} \\
     && \texttt{\textbar\space otherwise = False}\\ \hline
\end{tabularx}
\end{table}

SMURF allows 3 transformation operations to tone rows: inversion, retrograde and
transposition.
\begin{table} [H]
\centering
\begin{tabularx}{0.9\textwidth}{llX}
\hline\hline
Tone Row Operator & Description & Example \\
\hline\hline
   $\sim$ & Inversion & $\sim$ {\texttt row} (returns the inversion of {\texttt row})\\ \hline
   \textless\textgreater & Retrograde & \textless\textgreater~{\texttt row} (returns the
           retrograde of {\texttt row})\\ \hline
   $\wedge\wedge$ & Transposition & $\wedge\wedge$ {\texttt row} 3 (transpose {\texttt row} by 3
           semitones)\\ \hline
\end{tabularx}
\end{table}

\subsubsection{Separators}
Separators in SMURF are used to separate tokens. The definition os separators in
SMURF is 

\begin{grammar}
<separator> $\rightarrow$ \texttt{,} | \texttt{;} | \texttt{\&} | \it{whitespace}
\end{grammar}

where {\it comma} is used to separate elementes in list definitions.
{\it semicolon} is used to separate declarations in let bindings. 
When the symbole of \texttt{\&} is used, compiler will replay it with a {\it newline} symbol.
The definition of {\it whitespace} is in section~\ref{sec:whitespaces}. 


\subsubsection{Newlines}
SMURF uses {\it newline} to signify the end of a line of text. {\it Newlines}
are treated as a tokens in SMURF. They can change the semantic meaning of programs.


\subsection{Whitespaces}
\label{sec:whitespaces}
{\it Blank} and {\it tab} are referred to as {\it whitespaces} in SMURF. 
{\it Whitespaces} are used to
separating tokens as well as formatting programs. They are ignored in
SMURF programs. As a result, indentations are not significant in SMURF.


\subsection{Backslash Line Splicing}
In SMURF, you can use a \textbackslash\textless{\it newline}\textgreater~{}symbol to splice two lines. The symbol
will be ignored by compiler. E.g.
\begin{lstlisting}
genAltChords (x:y:ys) = [(x,Time 4,1)]   \
                        :[(y,Time 4,-1)]:genAltChords ys
\end{lstlisting}
will be treated as 
\begin{lstlisting}
genAltChords (x:y:ys) = [(x,Time 4,1)]:[(y,Time 4,-1)]:genAltChords ys
\end{lstlisting}
in SMURF.
