\section{Meaning of Identifiers}
In SMURF, identifiers refer to functions and variables.

\subsection{What Are They Need For}
\subsubsection{Functions}
There are two library functions that can be used in SMURF: head and tail.
\begin{itemize}
\item head: given a list of elements, return the first element in the list. If
not given a list or given an empty list, return error.
\item tail: given a list of elements, return the list with the first element
removed. If not given a list or given an empty list, return error.
\end{itemize}

\subsubsection{variables}
In SMURF, a variable is an abstraction of a computer memory cell or a collection
of memory cells. 
SMURF is a strongly typed programming language, which means the type of a variable can't
be changed once declared. Each variable has a static type which is automatically
deduced by the SMURF compiler. The variables in SMURF are immutable.

\subsection{Scope and Lifetime}
In SMURF, a variable is bound in its scope to a value using constructs like let or list
comprehensions. A variable is visible within its scope.
There is no global variables in SMURF. A variable becomes invalid after the 
ending of its scope.

\subsection{Basic Types}
There are two fundamental types in SMURF: int and bool. 
\begin{itemize}
\item Integer: int, used to represent integers.
\item Boolean: bool, used to represent boolean values.
\end{itemize}

\subsection{Structured Types}
Structured types hold groups of elements. There are two structured types in
SMURF: tuple and list.
\begin{itemize}
\item Tuples: (a, ..., n), where items a - n are elements in the tuple
  \begin{itemize}
  \item Elements can have different types 
  \end{itemize}
\item Lists:  [a, ..., n], where items a - n are elements in the list 
  \begin{itemize}
  \item Elements must have same type
  \end{itemize}
\end{itemize}


%\subsubsection{Function}

\subsection{Derived Types}
\subsubsection{Pitch}
pc (pitch classes) are represented by integers ranging from 0 to 11.
\begin{itemize}
  \item A Note with pc = -1 represents a rest. In this special case, the register for the Note only matters in relation
  to whether the rest lies on the treble or bass clef (i.e. whether the register is positive or negative)
\end{itemize}

\subsubsection{Beat}
A Beat represents a length of musical time. It has a Time tag and integer type. 
\begin{itemize}
  \item Must have the string ``Time" followed by an integer that is a power of 2 and \textless\space 32 in declaration
  \begin{itemize}
    \item whole note: Time 1
    \item half note: Time 2
    \item quarter note: Time 4
    \item eighth note: Time 8
    \item sixteenth note: Time 16
    \item thirty-second note: Time 32
  \end{itemize}
  \item Uses + operator to combine Time but only adds two operands that contain the same integer; recursively 
  checks for Time operands that contain the same integers until only unequal Time integers are left
  \begin{itemize}
    \item Time 4 + Time 16 + Time 16 + Time 16 + Time 16
    \item Time 4 + Time 8 + Time 16 + Time 16
    \item Time 4 + Time 8 + Time 8 
    \item Time 4 + Time 4 = Time 2 (quarter note + quarter note = half note)
  \end{itemize}
\end{itemize}

\subsubsection{Register}
Registers are represented by integers ranging from 0 to 3.
\begin{itemize}
  \item \begin{music}  \trebleclef  \end{music}  Treble Clef: notes middle C and
  higher represented by 2 and 3  
    \begin{itemize}
    \item middle C to the first B above middle C: 2 
    \item first C above middle C to next highest B: 3
    \end{itemize}
  \item \begin{music} \bassclef  \end{music}  Bass Clef: notes lower than middle
  C represented by 0 and 1 
    \begin{itemize}
    \item B directly below middle C to first C below middle C: 0
    \item next lowest B to next lowest C: 1
    \end{itemize}
\end{itemize}

\subsubsection{Note}
A Note is a tuple of three integers and is declared as 
\begin{verbatim}
(pc: int, beat: Beat, register: int)
\end{verbatim}

\subsubsection{Chord}
A Chord is a list of notes and is declared as [Note]. The compiler will check that all notes in the list have 
the same beat count.

% \subsubsection{Measure} 
% Measure are abandoned in lrm


