\section{Meaning of Identifiers}
In SMURF, an identifier is either a keyword or a name for a variable or a function. 
The naming rules for identifiers are defined in section~\ref{sec:identifiers}. This section outlines
the use and possible types of non-keyword identifiers.


\subsection{Purpose}
\subsubsection{Functions}
Functions in SMURF enable users to structure programs in a more modular way. 
Each function has at least one argument and exactly one return value, whose types need to be 
explicitly defined by the programmer. The function describes how to produce the return value,
given a certain set of arguments.
SMURF is a side effect free language, which means
that if provided with the same arguments, a function is guaranteed to return the same value. 


\subsubsection{Variables}
In SMURF, a variable is an identifier that is bound to a constant value
or to an expression. Any use of a variable within the scope of its definition
refers to the value or expression to which the variable was bound.
Each variable has a static type which can be automatically
deduced by the SMURF compiler, or explicitly defined by users. The variables in SMURF are immutable.


\subsection{Scope and Lifetime}
The lexical scope of a top-level binding in a SMURF program is the whole program itself.
As a result of this fact, a top-level binding can refer to any other top-level variable or function
on its right-hand side, regardless of which bindings occur first in the program.
Local bindings may also occur
with the \texttt{let} \emph{declarations} \texttt{in} \emph{expression} construct, and the
scope of a binding in \emph{declarations} is \emph{expression} and the right hand side of any other bindings in
\emph{declarations}. A variable or function is only visible within its scope.
An identifier becomes invalid after the ending of its scope. E.g.

\begin{lstlisting}
prime = [2,0,4,6,8,10,1,3,5,7,9,11] 
main = let prime = [0,2,4,6,8,10,1,3,5,7,9,11]
           p3 = (head prime) + 3
       in print (p3)
\end{lstlisting}

In line 1, \texttt{prime} is bound to a list of integers in a top-level definition, so it
has global scope.
In line 2, the \texttt{main} identifier (a special keyword described in \ref{sec:main}) 
is bound to a \texttt{let} expression. The \texttt{let} expression declares two local variables,
\texttt{prime} and \texttt{p3}. In line 3, the \texttt{head} function looks for a definition
of prime in the closest scope, and thus uses the binding in line 2. So the result
to be printed in line 4 should be 3. After line 4, the locally defined \texttt{prime} and
\texttt{p3} variables will be invalid and can't be accessed anymore.

\subsection{Basic Types}
\label{sec:basictype}
There are three fundamental types in SMURF: {\texttt Int}, {\texttt Bool} and {\texttt Beat}. 
\begin{itemize}
\item Integer: \texttt{Int}, used to represent integers.
\item Boolean: \texttt{Bool}, used to represent Boolean values.
\item Beat   : \texttt{Beat}, used to represent the duration of a note. The value of {\texttt Beat} are integers of the power of 2, ranging from 1 to 16.
\end{itemize}

\subsection{Structured Types}
\label{sec:structtype}
Structured types hold groups of elements. There are two structured types in
SMURF: {\it list} and {\it function}.

{\it list} has the format of 
\begin{grammar}
<list> $\rightarrow$ [{\it a, ..., n}]
\end{grammar}
where items {\it a - n} are elements in the list. Elements
of lists must have the same type.

{\it function} has the format of 
\begin{grammar}
<function> $\rightarrow$ {\it arg1} {\texttt -\textgreater} ... {\texttt
    -\textgreater} {\it argk}
{\texttt -\textgreater} {\it return-value}
\end{grammar}
where {\it arg1 - argk} are the inputs of function and {\it return-value} is the
output of the function.


\subsection{Derived Types}
\label{sec:derivedtype}
Besides the basic types, SMURF has also several derived types. 

The type of \texttt{Note} is used to represent a musical note in SMURF. The format of \texttt{Note} is defined as below.
\begin{grammar}
<note> $\rightarrow$ ({\it pc}, {\it reg})\^{\it k}[.]* 
\end{grammar}
where {\it pc} is an integer in the range from -1 to 11. When {\it pc} 
has a value of -1, the note is a rest, otherwise it represents the pitch class of 
the note. 
{\it reg} is an integer in the range of 0-3, representing the register of the 
note, where the integer values and corresponding registers are given below.
\begin{itemize}
    \item 0: Bass clef, B directly below middle C to first C below middle C
    \item 1: Bass clef, next lowest B to next lowest C
    \item 2: Treble clef, middle C to the first B above middle C
    \item 3: Treble clef, first C above middle C to next highest B
\end{itemize}
{\it k} stands for the beat of the note.
Periods following {\it k} are optional. Users can add dots until the added duration
gets down to 16th note.

The type of \texttt{Chord} is used to represent several notes to be played simultaneously. It is defined as 
\begin{grammar}
<chord> $\rightarrow$ [{\it note}]
\end{grammar}
The compiler will check to make sure all the {\it note} in the same {\it chord} have the same time duration.

The type of \texttt{System} is used to represent a list of {\it chord} to be played in a sequential patterns. It is defined as 
\begin{grammar}
<system> $\rightarrow$ [{\it chord}]
\end{grammar}


\begin{comment}

\subsubsection{Pitch}
pc (pitch classes) are represented by integers ranging from 0 to 11.
\begin{itemize}
  \item A Note with pc = -1 represents a rest. In this special case, the register for the Note only matters in relation
  to whether the rest lies on the treble or bass clef (i.e. whether the register is positive or negative)
\end{itemize}

\subsubsection{Beat}
A Beat represents a length of musical time. It has a Time tag and integer type. 
\begin{itemize}
  \item Must have the string ``Time" followed by an integer that is a power of 2 and \textless\space 32 in declaration
  \begin{itemize}
    \item whole note: Time 1
    \item half note: Time 2
    \item quarter note: Time 4
    \item eighth note: Time 8
    \item sixteenth note: Time 16
    \item thirty-second note: Time 32
  \end{itemize}
  \item Uses + operator to combine Time but only adds two operands that contain the same integer; recursively 
  checks for Time operands that contain the same integers until only unequal Time integers are left
  \begin{itemize}
    \item Time 4 + Time 16 + Time 16 + Time 16 + Time 16
    \item Time 4 + Time 8 + Time 16 + Time 16
    \item Time 4 + Time 8 + Time 8 
    \item Time 4 + Time 4 = Time 2 (quarter note + quarter note = half note)
  \end{itemize}
\end{itemize}

\subsubsection{Register}
Registers are represented by integers ranging from 0 to 3.
\begin{itemize}
  \item \begin{music}  \trebleclef  \end{music}  Treble Clef: notes middle C and
  higher represented by 2 and 3  
    \begin{itemize}
    \item middle C to the first B above middle C: 2 
    \item first C above middle C to next highest B: 3
    \end{itemize}
  \item \begin{music} \bassclef  \end{music}  Bass Clef: notes lower than middle
  C represented by 0 and 1 
    \begin{itemize}
    \item B directly below middle C to first C below middle C: 0
    \item next lowest B to next lowest C: 1
    \end{itemize}
\end{itemize}

\subsubsection{Note}
A Note is a tuple of three integers and is declared as 
\begin{verbatim}
(pc: int, beat: Beat, register: int)
\end{verbatim}

\subsubsection{Chord}
A Chord is a list of notes and is declared as [Note]. The compiler will check that all notes in the list have 
the same beat count.
\end{comment}

% \subsubsection{Measure} 
% Measure are abandoned in lrm


