\section{Meaning of Identifiers}
In SMURF, identifiers refer to functions and variables.

\subsection{What Are They Need For}
\subsubsection{Functions}
Functions in SMURF enable us to structure our programs in a more modular way. 
A function is a group of statements that is executed when it is called from some
point of the program. 

\subsubsection{variables}
In SMURF, a variable is an abstraction of a computer memory cell or a collection
of memory cells. 
SMURF is a strongly typed programming language, which means the type of a variable can't
be changed once declared. Each variable has a static type which is automatically
deduced by the SMURF compiler. The variables in SMURF are immutable.

\subsection{Scope and Lifetime}
In SMURF, a variable is bound in its scope to a value using constructs like
\texttt{let} or list comprehensions. A variable is visible within its scope.
There is no global variables in SMURF. A variable becomes invalid after the 
ending of its scope.

\subsection{Basic Types}
There are two fundamental types in SMURF: int and bool. 
\begin{itemize}
\item Integer: \texttt{int}, used to represent integers.
\item Boolean: \texttt{bool}, used to represent boolean values.
\end{itemize}

\subsection{Structured Types}
Structured types hold groups of elements. There are three structured types in
SMURF: tuples, lists and functions.

Tuples have the format of 
\begin{verbatim}
(a, ..., n)
\end{verbatim}
where items \texttt{a - n} are elements in the tuple. Elements
of tuples can have different types.

Lists have the format of 
\begin{verbatim}
[a, ..., n]
\end{verbatim}
where items \texttt{a - n} are elements in the list. Elements
of lists must have the same type.

Functions have the format of 
\begin{verbatim}
arg1 -> arg2 -> ... -> argk -> return-value
\end{verbatim}
where \texttt{arg1 - argk} are the types of arguments of function.


\subsection{Derived Types}
SMURF has a derived type of \texttt{note}, which has the format of 
\begin{verbatim}
(pc, reg)^k[.]*
\end{verbatim}
where \texttt{pc} is an integer in the range from -1 to 11. When \texttt{pc} 
has a value of -1, the note is a rest, other it represents the pitch class of 
the note. 
\texttt{reg} is an integer in the range of 0-3, representing the register of the 
note. The register of the note is Bass 1, Bass 2, Treble 1 and Treble 2 for the
\texttt{reg} value from 0 to 3 repectively.
\texttt{k} is an integer of the power of 2, ranging from 1 to 16. 
Periods following \texttt{k} are optional. Users can add dots until the added duration
gets down to 16th note.

\begin{comment}

\subsubsection{Pitch}
pc (pitch classes) are represented by integers ranging from 0 to 11.
\begin{itemize}
  \item A Note with pc = -1 represents a rest. In this special case, the register for the Note only matters in relation
  to whether the rest lies on the treble or bass clef (i.e. whether the register is positive or negative)
\end{itemize}

\subsubsection{Beat}
A Beat represents a length of musical time. It has a Time tag and integer type. 
\begin{itemize}
  \item Must have the string ``Time" followed by an integer that is a power of 2 and \textless\space 32 in declaration
  \begin{itemize}
    \item whole note: Time 1
    \item half note: Time 2
    \item quarter note: Time 4
    \item eighth note: Time 8
    \item sixteenth note: Time 16
    \item thirty-second note: Time 32
  \end{itemize}
  \item Uses + operator to combine Time but only adds two operands that contain the same integer; recursively 
  checks for Time operands that contain the same integers until only unequal Time integers are left
  \begin{itemize}
    \item Time 4 + Time 16 + Time 16 + Time 16 + Time 16
    \item Time 4 + Time 8 + Time 16 + Time 16
    \item Time 4 + Time 8 + Time 8 
    \item Time 4 + Time 4 = Time 2 (quarter note + quarter note = half note)
  \end{itemize}
\end{itemize}

\subsubsection{Register}
Registers are represented by integers ranging from 0 to 3.
\begin{itemize}
  \item \begin{music}  \trebleclef  \end{music}  Treble Clef: notes middle C and
  higher represented by 2 and 3  
    \begin{itemize}
    \item middle C to the first B above middle C: 2 
    \item first C above middle C to next highest B: 3
    \end{itemize}
  \item \begin{music} \bassclef  \end{music}  Bass Clef: notes lower than middle
  C represented by 0 and 1 
    \begin{itemize}
    \item B directly below middle C to first C below middle C: 0
    \item next lowest B to next lowest C: 1
    \end{itemize}
\end{itemize}

\subsubsection{Note}
A Note is a tuple of three integers and is declared as 
\begin{verbatim}
(pc: int, beat: Beat, register: int)
\end{verbatim}

\subsubsection{Chord}
A Chord is a list of notes and is declared as [Note]. The compiler will check that all notes in the list have 
the same beat count.
\end{comment}

% \subsubsection{Measure} 
% Measure are abandoned in lrm


