\section{Expressions}

This section describes the syntax and semantics of \emph{expressions} in 
SMURF. Expressions can have either infix or prefix operators. All 
infix operators are built in operators. Unless otherwise stated infix 
operators are left associated. All prefix operators (function calls) 
are left associated. Prefix operators will always evaluate with a 
higher precedence than infix operators.  


\begin{center}
	\begin{tabular}{|c|c|}
		\hline
		Expression & Association \\
		\hline
		\texttt{f x + g y} & \texttt{(f x) + (g y)} \\
		\texttt{f g x} & \texttt{(f (g x))} \\
		\texttt{ let \{ ... \} in x + y} & \texttt{let \{ ... \} in (x + y)} \\
		type declaration example & order of precedence \\
		\hline
	\end{tabular}
\end{center}


\subsection{Errors}

Errors can occur during runtime of a SMURF program. These erros cannot be 
caught by a programmer nor can a programmer produce an error artificially. 
Errors that occur during runtime are out of bounds errors in \texttt{Note} 
and \texttt{Beat} creation.

\subsection{Curried Applications}

    \subsubsection{Function declaration}
    The syntax of a function declaration is as follows: 
    \begin{verbatim} 
    function-expression :: argument-type-list -> result-type 
    \end{verbatim} 
    where
    \begin{verbatim}
    argument-type-list:     argument-type
                            argument-type-list  argument-type
    \end{verbatim} 
A function declaration must be on its own line and must declare a type. Declaring a general type is allowed. There are no explicit return statements.
  
    \subsubsection{Function application}
    The syntax of a function application is as follows: 
    \begin{verbatim}
    function-expression  argument-expression-list \end{verbatim} 
    where
    \begin{verbatim}
    argument-expression-list:     argument-expression
                                  argument-expression-list  argument-expression
    \end{verbatim} 
A function application associates from left to right, so parentheses are optional: 
    \begin{verbatim}
    funct a b
    \end{verbatim}
    is equivalent to
    \begin{verbatim}
    ((funct a) b) 
    \end{verbatim}
    Parentheses are used to change the precedence from the default. The following evaluates funct1 with argument b then evaluates funct2 with argument a:
    \begin{verbatim}
    funct2 a (funct1 b)
    \end{verbatim}   

  \subsubsection{**PARTIAL APPLICATION**}
  

\subsection{Operator Application}
  The syntax for applying a binary operator to two expressions is infix:
    \begin{verbatim}
    expression  operator  expression \end{verbatim} 
    where
    \begin{verbatim}
    operator:     arithmetic-operator
                  comparison-operator
                  boolean-operator
                  list-operator
                  function-operator \end{verbatim} 

\subsection{Conditionals}
  The syntax for conditional expressions is as follows:
  \begin{verbatim}
  if  expression  then expression-true  else expression-false \end{verbatim} 
  When the value of expression evaluates to true, expression-true is evaluated, otherwise expression-false is evaluated. Conditional expressions do not have newline restrictions.

\subsection{Lists}
Lists are written as:
  \begin{verbatim}
  [expression-list]\end{verbatim}
  where
  \begin{verbatim}
  expression-list:     <empty>
                       expression
                       expression-list,  expression \end{verbatim}
[expression$_{1}$, ..., expression$_{k}$]  =  expression$_{1}$ : ( expression$_{2}$ : (... (expression$_{k}$ : [ ] )) \\ \\
where \textit{k} \textgreater\space 0. The expressions in a list must all be of the same type. Both the list constructor : and empty list [ ] are reserved as part of the language syntax and therefore cannot be hidden or redefined. The list constructor has right associativity.

\subsection{Tuples}
Tuples are written as:
  \begin{verbatim}
  (expression-list)\end{verbatim}
  where
  \begin{verbatim}
  expression-list:     expression, expression
                       expression-list,  expression \end{verbatim}
The expressions in a tuple may be of different types. The constructor of an n-tuple is denoted by (\textunderscore
, ..., \textunderscore) where there are \textit{n-1} commas.

\subsection{Parenthesized Expressions}
Parenthesized expressions has the form:
  \begin{verbatim}
  (expression)\end{verbatim}
  where expression is evaluated as a primary expression.

\subsection{Expression Type-Signature}
Expression type-signatures have the form:
  \begin{verbatim}
  expression :: type \end{verbatim}
  where expression is an expression and type is a type. This is used to explicitly define a type for an expression. The declared type may be more specific than the principal type but it is illegal to give a declared type that is more general than the principal type. Giving a declared type that is not comparable to the principal type will also yield an error.
