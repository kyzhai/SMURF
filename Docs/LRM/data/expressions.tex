\section{Expressions}

This section describes the syntax and semantics of \emph{expressions} in 
SMURF. Expressions can have either infix or prefix operators. All 
infix operators are built in operators. Unless otherwise stated infix 
operators are left associated. All prefix operators (function calls) 
are left associated. Prefix operators will always evaluate with a 
higher precedence than infix operators.  


%TODO: check the correct position for this table
\begin{center}
	\begin{tabular}{|c|c|}
		\hline
		Expression & Association \\
		\hline
		\texttt{f x + g y} & \texttt{(f x) + (g y)} \\
		\texttt{f g x} & \texttt{(f (g x))} \\
		\texttt{ let \{ ... \} in x + y} & \texttt{let \{ ... \} in (x + y)} \\
		type declaration example & order of precedence \\
		\hline
	\end{tabular}
\end{center}


\subsection{Errors}

Errors can occur during runtime of a SMURF program. These erros cannot be 
caught by a programmer nor can a programmer produce an error artificially. 
Errors that occur during runtime are out of bounds errors in \texttt{Note} 
and \texttt{Beat} creation.

\subsection{Description of Precedence}


\subsection{Primary Expressions}

\subsubsection{Identifiers}
An identifier expression is an expression that involves only identifiers. 
\begin{verbatim}
identifier-expression :: identifiers
\end{verbatim}
where \texttt{identifiers} are defined in section~\ref{sec:identifiers}.


\subsubsection{Constants}
A constant expression is an expression that involves only constants. 
\begin{verbatim}
constant-expression :: constants
\end{verbatim}
where \texttt{constants} are defined in section~\ref{sec:constants}.

\subsubsection{(Expression)}
An expression surrounded by parentheses is a new expression.
\begin{verbatim}
paren-expression :: ( expression )
\end{verbatim}


\subsection{Curried Applications}

    \subsubsection{Function declaration}
    \emph{function-expression} \texttt{::}  \emph{argument-type-list} \texttt{$\rightarrow$} \emph{result-type} \\ \\
    where\\
    
    \emph{argument-type-list} $\rightarrow$ \emph{argument-type}$+$ \\ \\
    A function declaration must be on its own line and must declare a type. Declaring a general type is allowed. There are no explicit return statements.
  
    \subsubsection{Function application}
    \emph{function-expression} \emph{argument-expression-list} \\ \\
    where\\
    
    \emph{argument-expression-list} $\rightarrow$ \emph{argument-expression}$+$ \\ \\ 
    A function application associates from left to right, so parentheses are optional: \\
    
    \emph{funct a b}  is equivalent to \emph{((funct a) b)} \\ \\
    Parentheses are used to change the precedence from the default. The following evaluates function \emph{funct1} with argument \emph{b} then 
    evaluates function \emph{funct2} with argument \emph{a}: \\
    
    \emph{funct2 a (funct1 b)}

  \subsubsection{**PARTIAL APPLICATION**}
  

\subsection{Operator Application}
    \emph{expression  operator  expression}\\ \\
    where\\
    
    \emph{operator} $\rightarrow$ \emph{arithmetic-operator} $ | $  \emph{comparison-operator} $ | $ \emph{boolean-operator} $ | $ 
    
    \emph{list-operator} $ | $ \emph{function-operator}
    
\subsection{Conditionals}
  \texttt{if}  \emph{expression}  \texttt{then}  \emph{expression-true}  \texttt{else}  \emph{expression-false} \\ \\
  When the value of expression evaluates to true,  \emph{expression-true} is evaluated, otherwise  \emph{expression-false} is evaluated. Conditional expressions do not have newline restrictions.

\subsection{Lists}
  \texttt{[} \emph{expression-list} \texttt{]} \\ \\
  where \\
  
  \emph{expression-list} $\rightarrow$  \emph{expression}$?$ (\texttt{,} \emph{expression})$*$ \\ \\
\texttt{[}\emph{expression$_{1}$}\texttt{,} \emph{...}\texttt{,} \emph{expression$_{k}$}\texttt{]} = 
  \emph{expression$_{1}$}\texttt{:(}\emph{expression$_{2}$}\texttt{:(} \emph{...} \texttt{(}\emph{expression$_{k}$}\texttt{:[ ]))} \\ 
where \textit{k} \textgreater\space 0. The expressions in a list must all be of the same type. Both the list constructor \texttt{:} and empty list \texttt{[ ]} are reserved as part of the language syntax and therefore cannot be hidden or redefined. The list constructor has right associativity.

\subsection{Tuples}
  \texttt{(} \emph{expression-list} \texttt{)} \\ \\
  where \\
  
  \emph{expression-list} $\rightarrow$  \emph{expression} (\texttt{,} \emph{expression})$*$  \texttt{,} \emph{expression} \\ \\
The expressions in a tuple may be of different types. The constructor of an n-tuple is denoted by (\textunderscore
, ..., \textunderscore) where there are \textit{n-1} commas.

\subsection{Parenthesized Expressions}
  \texttt{(} \emph{expression} \texttt{)} \\ \\
  where expression is evaluated as a primary expression.

\subsection{Expression Type-Signature}
  \emph{expression} \texttt{::} \emph{type} \\ \\
  where \emph{expression} is an expression and \emph{type} is a type. This is used to explicitly define a type for an expression. The declared type may be more specific than the principal type but it is illegal to give a declared type that is more general than the principal type. Giving a declared type that is not comparable to the principal type will also yield an error.

\subsection{Let Expressions}
\begin{grammar}
<let-exp> $\rightarrow$ let <decls> in <expression>
\end{grammar}
Let expressions have the form \emph{let \{} $d_1;...;d_n$ \} \emph{in e}, where $d_n$ is the nth declaration and \emph{e} is an expression. Note that the scope of $d_n$ is in \emph{e}.

% are pattern bindings matched lazily?

\subsection{Pattern Matching}

\setlength{\grammarindent}{5em}
\begin{grammar}
<pattern> $\rightarrow$ <pat> \\ <pat> \texttt{:} <pattern> \\ \texttt{[} <pattern-list>$?$ \texttt{]} \\
												\texttt{(} <pattern> \texttt{)} \\


<pattern-list> $\rightarrow$ <pat> (\texttt{,} <pat>)* 

<pat> $\rightarrow$ <identifier> \\ <constant> \\ \texttt{_}
												
\end{grammar}

A \emph{pattern} can be used in a function declaration to ``match" against arguments passed to the function. The
arguments are evaluated and the resultant values are matched against the patterns in the same order they were given
to the function. If the pattern
is a constant, the argument must be the same constant or evaluate to that constant value in order for a match to
occur. If the pattern is an identifier, the argument's value is bound to that identifier in the scope of the
function declaration where the pattern was used. If the pattern is the wildcard character `\texttt{_}', 
any argument will be matched and no binding will occur. If the pattern is structured, the argument must follow
the same structure in order for a match to occur. 

Below, we have defined an example function \texttt{f} that takes two arguments. 
The value of the function call is dependent
on which patterns are matched. The patterns are checked against the arguments from top to bottom i.e. the first
function declaration's patterns are checked, then if there isn't a match, the next set of patterns are checked,
and so on. In this example, we first check if the second argument is the empty list (we disregard the first
argument using the wildcard character), and return False if it is. Otherwise, we check if the second argument
is composed of two elements, and, if so, the first element is bound to \texttt{x} and the second is bound to
\texttt{y} in the expression to the right of the binding operator \texttt{=}, and that expression is evaluated and
returned. If that match failed, we check if the first argument is zero and disregard the second. Finally, if
none of the previous pattern sets matched, we bind the first argument to \texttt{m}, the head of the
second argument to \texttt{x}, and the rest of the second argument to \texttt{rest}. Note we can do this
as we already checked if the second argument was the empty list, and, since we did not match that pattern,
we can assume there is at least one element in the list.

\begin{verbatim}
f :: Int -> [Int] -> Bool
f _ [] = False
f _ [x, y] = if x then True else False
f 0 _ = True
f x l = if x == (head x) then True else False
f m x:rest = f m rest 
\end{verbatim}

\subsection{Guards}
\begin{grammar}
<guard> $\rightarrow$  let <decls> | <infixexp>          
\end{grammar}

There are two kinds of guards in SMURF: local bindings and boolean guards. Local bindings have the form let $<decls>$ and introduces the declarations to the program environment. Boolean guards are expressions of type Bool. The boolean guard succeeds if the expression evaluates to True.

