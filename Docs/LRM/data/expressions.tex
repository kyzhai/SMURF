\section{Expressions}

This section describes the syntax and semantics of \emph{expressions} in 
SMURF. Expressions can have either infix or prefix operators. 
Unless otherwise stated infix operators are left associated. 
All prefix operators are left associated. Prefix operators will always 
evaluate with a higher precedence than infix operators.  


%TODO: check the correct position for this table
\begin{center}
	\begin{tabular}{|c|c|}
		\hline
		Expression & Association \\
		\hline
		\texttt{f x + g y} & \texttt{(f x) + (g y)} \\
		\texttt{f g x} & \texttt{((f g) x)} \\
		\texttt{ let \{ ... \} in x + y} & \texttt{let \{ ... \} in (x + y)} \\
		\hline
	\end{tabular}
\end{center}


\subsection{Errors}

Errors can only occur during compilation of a SMURF program. All generated 
code will run successfully. 

\subsection{Description of Precedence}
Precedence describes the order of all operations on operands including 
built-in operators and functions and user created functions. All 
functions have the same precedence. Function precedence is higher than all
operators. The operator precedence will be as listed below. They are listed 
in order of precedence between the different types of operators with the 
top operators having the lowest precedence and the bottom operators having 
the highest precedence. 

\subsubsection{Declaration Operators}
Declaration operators are used in declarations. These 
operators are \texttt{::}, \texttt{->}, and \texttt{|}. 
All three operators have the same level of precedence. 
\subsubsection{Tone Row Operators}
Tone row operators manipulate lists of notes. 
The three operators are ~, \texttt{<>}, and \texttt{wedge wedge}. 
The ~ operator has the highest precedence of the tone row 
operators. Next highest operator is \texttt{$\wedge$}. While \texttt{<>} 
has the lowest precedence of the tone row operators. 
\subsubsection{Boolean Operators}
Boolean operators are used to do boolean logic on 
boolean types. The order of precedence for these 
operators is, lowest to highest, \texttt{||}, 
\texttt{\&\&}, \texttt{==} and \texttt{!=} , and \texttt{!}. 
\subsubsection{Comparison Operators}
Comparison operators are used to compare primitive types sizes. 
All comparison operators have the same precedence. 
\subsubsection{Arithmetic Operators}
There are three types of arithmetic operator. There are 
basic operators found in most programming languages like 
\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, and \texttt{\%}. 
There are also more advance operators for modulus arithmetic commonly 
found in twelve tone serialism like \texttt{\%+} and \texttt{\%-}. 
Last their are \texttt{Beat} arithmetic operators. 
These include \texttt{\^+}, \texttt{\^-}, \texttt{\^*}, \texttt{\^/}, 
and \texttt{.}. 

Basic arithmetic operators have a higher precedence than both
modulus and \texttt{Beat} arithmetic operators. Modulus operators 
then have a higher precedence than \texttt{Beat} operators. 

In basic arithmetic operators \texttt{*}, \texttt{/}, and \texttt{\%} 
have higher precedence than \texttt{+} and \texttt{-}. 
Both modulus operators have the same precedence. In \texttt{Beat} 
operators the highest precedence operator is \texttt{.} followed 
by \texttt{\^*} and \texttt{\^/} with \texttt{\^+} and {\^-} having 
the lowest precedence. 
\subsubsection{List Operators}
List operators are manipulate lists. There are two of these operators,
: and ++. The : operator will be evaluated before the ++ operator. 

\subsection{Primary Expressions}

\subsubsection{Identifiers}
An identifier expression is an expression that involves only identifiers. 
\begin{verbatim}
identifier-expression :: identifiers
\end{verbatim}
where \texttt{identifiers} are defined in section~\ref{sec:identifiers}.


\subsubsection{Constants}
A constant expression is an expression that involves only constants. 
\begin{verbatim}
constant-expression :: constants
\end{verbatim}
where \texttt{constants} are defined in section~\ref{sec:constants}.

\subsubsection{(Expression)}
An expression surrounded by parentheses is a new expression.
\begin{verbatim}
paren-expression :: ( expression )
\end{verbatim}

\subsection{Function application}
    \emph{function-expression} \emph{argument-expression-list} \\ \\
    where\\
    
    \emph{argument-expression-list} $\rightarrow$ \emph{identifier}$+$ $|$ \emph{expression}$+$ \\ \\ 
    A function application associates from left to right, so parentheses are optional: \\
    
    \emph{funct a b}  is equivalent to \emph{((funct a) b)} \\ \\
    Parentheses are used to change the precedence from the default. The following evaluates function \emph{funct1} with argument \emph{b} then 
    evaluates function \emph{funct2} with argument \emph{a}: \\
    
    \emph{funct2 a (funct1 b)}


\subsection{Operator Application}
    \emph{expression$_{1}$  operator  expression$_{2}$}\\ \\
    where\\
    
    \emph{operator} $\rightarrow$ 
        \emph{operator$_{arithmetic}$} $|$
        \emph{operator$_{comparison}$}  $|$ 
        \emph{operator$_{boolean}$}  $|$
        \emph{operator$_{list}$}  $|$
        \emph{operator$_{binding}$} \\ \\
OR\\ \\
          \emph{operator  expression$_{1}$}\\ \\
    where\\
    
    \emph{operator} $\rightarrow$ \emph{operator$_{negation}$} \\ \\
\textbf{\emph{operator$_{arithmetic}$}} \\
For integer arithmetic, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to integers. For beat arithmetic, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to integers that are powers of 2 from 1 to 16. For pitch class arithmetic, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to integers between 0 and 11.  \\ \\
\textbf{\emph{operator$_{comparison}$}} \\
For integer comparison, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to integers. For beat comparison, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to beats. \\ \\
\textbf{\emph{operator$_{boolean}$}} \\
For comparison, conjunction, and disjunction, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to integers. \\ \\
\textbf{\emph{operator$_{list}$}} \\ \\
List operators require that  \emph{expression$_{2}$} is a list. When doing list construction,  \emph{expression$_{1}$} must be an element of the same type as the other elements in  \emph{expression$_{2}$}. When doing list concatenation,  \emph{expression$_{1}$} must be a list containing elements of the same type as  \emph{expression$_{2}$}. \\ \\
\textbf{\emph{operator$_{binding}$}} \\ \\
When doing type specification, \emph{expression$_{2}$} must be a type and \emph{expression$_{1}$} must be a non-keyword identifier. When doing argument and function return type specification, \emph{expression$_{1}$} and \emph{expression$_{2}$} must be types. When using case alternatives with guards,  \emph{expression$_{2}$} is a conditional expression and  \emph{expression$_{1}$} is either a conditional expression, indicating that there is more than one case for the guard, or a declaration. When doing assignment,  \emph{expression$_{1}$} is a non-keyword identifier and  \emph{expression$_{2}$} is an expression to bind to that identifier. \\ \\
\textbf{\emph{operator$_{negation}$}} \\ \\
For negation,  \emph{expression$_{1}$} is a comparison, conjunction, or disjunction expression.
    
\subsection{Conditionals}
  \texttt{if} \emph{expression$_{boolean}$} \texttt{then}  \emph{expression$_{true}$} \texttt{else}  \emph{expression$_{false}$} \\ \\
  When the value of \emph{expression$_{boolean}$} evaluates to true, \emph{expression$_{true}$} is evaluated, otherwise  \emph{expression$_{false}$} is evaluated. Conditional expressions do not have newline restrictions.

\subsection{Lists}
  \texttt{[} \emph{expression-list} \texttt{]} \\ \\
  where \\
  
  \emph{expression-list} $\rightarrow$  
  \emph{\textless empty \textgreater} $|$
  \emph{expression} (\texttt{,} \emph{expression})$*$  \\ \\
An example of how a list can be written is: \\

\texttt{[}\emph{expression$_{1}$}\texttt{,} \emph{...}\texttt{,} \emph{expression$_{k}$}\texttt{]} = 
  \emph{expression$_{1}$}\texttt{:(}\emph{expression$_{2}$}\texttt{:(} \emph{...} \texttt{(}\emph{expression$_{k}$}\texttt{:[ ]))} \\ \\
where \textit{k} \textgreater\space 0. The expressions in a list must all be of the same type. Both the list constructor \texttt{:} and empty list \texttt{[ ]} are reserved as part of the language syntax and therefore cannot be hidden or redefined. The list constructor has right associativity.

\subsection{Parenthesized Expressions}
  \texttt{(} \emph{expression} \texttt{)} \\ \\
  where \emph{expression} is evaluated as a primary expression. Parentheses are used to increase the precedence of an expression. For example 2 \texttt{+} 3 \texttt{*}  4  evaluates to 14 but \texttt{(} 2 \texttt{+} 3 \texttt{) *}  4 evaluates to 20. The parentheses force the addition operation to occur before the multiplication operation even though multiplication has higher precedence than addition in SMURF.

\subsection{Let Expressions}
\begin{grammar}
<let-exp> $\rightarrow$ \texttt{let} <decls>+ \texttt{in} <expression>
\end{grammar}
Let expressions have the form \texttt{let} \emph{decls} \texttt{in} \emph{e}, where \emph{decls} is a list of one or more declarations and \emph{e} is an expression. Note that the scope of \emph{decls} is in expression \emph{e}. 

The declarations in a let expression can be separated by an \& symbol and also by a newline character. For example:

\begin{verbatim}
let x = 2 & y = 4 & z = 8 
in x + y + z
\end{verbatim}
Using only newline as a separator for declarations, the example would be as follows:

\begin{verbatim}
let x = 2
    y = 4
    z = 8
in x + y + z
\end{verbatim}

\subsection{Pattern Matching}

\setlength{\grammarindent}{5em}
\begin{grammar}
<pattern> $\rightarrow$ <pat> \\ <pat> \texttt{:} <pattern> \\ \texttt{[} <pattern-list>$?$ \texttt{]} \\
												\texttt{(} <pattern> \texttt{)} \\


<pattern-list> $\rightarrow$ <pat> (\texttt{,} <pat>)* 

<pat> $\rightarrow$ <identifier> \\ <constant> \\ \texttt{_}
												
\end{grammar}

A \emph{pattern} can be used in a function declaration to ``match" against arguments passed to the function. The
arguments are evaluated and the resultant values are matched against the patterns in the same order they were given
to the function. If the pattern
is a constant, the argument must be the same constant or evaluate to that constant value in order for a match to
occur. If the pattern is an identifier, the argument's value is bound to that identifier in the scope of the
function declaration where the pattern was used. If the pattern is the wildcard character `\texttt{_}', 
any argument will be matched and no binding will occur. If the pattern is structured, the argument must follow
the same structure in order for a match to occur. 

Below, we have defined an example function \texttt{f} that takes two arguments. 
The value of the function call is dependent
on which patterns are matched. The patterns are checked against the arguments from top to bottom i.e. the first
function declaration's patterns are checked, then if there isn't a match, the next set of patterns are checked,
and so on. In this example, we first check if the second argument is the empty list (we disregard the first
argument using the wildcard character), and return False if it is. Otherwise, we check if the second argument
is composed of two elements, and, if so, the first element is bound to \texttt{x} and the second is bound to
\texttt{y} in the expression to the right of the binding operator \texttt{=}, and that expression is evaluated and
returned. If that match failed, we check if the first argument is zero and disregard the second. Finally, if
none of the previous pattern sets matched, we bind the first argument to \texttt{m}, the head of the
second argument to \texttt{x}, and the rest of the second argument to \texttt{rest}. Note we can do this
as we already checked if the second argument was the empty list, and, since we did not match that pattern,
we can assume there is at least one element in the list.

\begin{verbatim}
f :: Int -> [Int] -> Bool
f _ [] = False
f _ [x, y] = if x then True else False
f 0 _ = True
f x l = if x == (head x) then True else False
f m x:rest = f m rest 
\end{verbatim}

\subsection{Guards}
\begin{grammar}
<guard> $\rightarrow$  let <decls> | <infixexp>          
\end{grammar}

There are two kinds of guards in SMURF: local bindings and boolean guards. Local bindings have the form let $<decls>$ and introduces the declarations to the program environment. Boolean guards are expressions of type Bool. The boolean guard succeeds if the expression evaluates to True.

