\section{Expressions}

This section describes the syntax and semantics of \emph{expressions} in 
SMURF. Expressions can have either infix or prefix operators. All 
infix operators are built in operators. Unless otherwise stated infix 
operators are left associated. All prefix operators (function calls) 
are left associated. Prefix operators will always evaluate with a 
higher precedence than infix operators.  


%TODO: check the correct position for this table
\begin{center}
	\begin{tabular}{|c|c|}
		\hline
		Expression & Association \\
		\hline
		\texttt{f x + g y} & \texttt{(f x) + (g y)} \\
		\texttt{f g x} & \texttt{(f (g x))} \\
		\texttt{ let \{ ... \} in x + y} & \texttt{let \{ ... \} in (x + y)} \\
		type declaration example & order of precedence \\
		\hline
	\end{tabular}
\end{center}


\subsection{Errors}

Errors can occur during runtime of a SMURF program. These erros cannot be 
caught by a programmer nor can a programmer produce an error artificially. 
Errors that occur during runtime are out of bounds errors in \texttt{Note} 
and \texttt{Beat} creation.

\subsection{Description of Precedence}


\subsection{Primary Expressions}

\subsubsection{Identifiers}
An identifier expression is an expression that involves only identifiers. 
\begin{verbatim}
identifier-expression :: identifiers
\end{verbatim}
where \texttt{identifiers} are defined in section~\ref{sec:identifiers}.


\subsubsection{Constants}
A constant expression is an expression that involves only constants. 
\begin{verbatim}
constant-expression :: constants
\end{verbatim}
where \texttt{constants} are defined in section~\ref{sec:constants}.

\subsubsection{(Expression)}
An expression surrounded by parentheses is a new expression.
\begin{verbatim}
paren-expression :: ( expression )
\end{verbatim}


\subsection{Curried Applications}
  
    \subsubsection{Function application}
    \emph{function-expression} \emph{argument-expression-list} \\ \\
    where\\
    
    \emph{argument-expression-list} $\rightarrow$ \emph{identifier}$+$ $|$ \emph{expression}$+$ \\ \\ 
    A function application associates from left to right, so parentheses are optional: \\
    
    \emph{funct a b}  is equivalent to \emph{((funct a) b)} \\ \\
    Parentheses are used to change the precedence from the default. The following evaluates function \emph{funct1} with argument \emph{b} then 
    evaluates function \emph{funct2} with argument \emph{a}: \\
    
    \emph{funct2 a (funct1 b)}

  \subsubsection{**PARTIAL APPLICATION**}
  

\subsection{Operator Application}
    \emph{expression$_{1}$  operator  expression$_{2}$}\\ \\
    where\\
    
    \emph{operator} $\rightarrow$ 
        \emph{operator$_{arithmetic}$} $|$
        \emph{operator$_{comparison}$}  $|$ 
        \emph{operator$_{boolean}$}  $|$
        \emph{operator$_{list}$}  $|$
        \emph{operator$_{binding}$} \\ \\
OR\\ \\
          \emph{operator  expression$_{1}$}\\ \\
    where\\
    
    \emph{operator} $\rightarrow$ \emph{operator$_{negation}$} \\ \\
\textbf{\emph{operator$_{arithmetic}$}} \\
For integer arithmetic, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to integers. For beat arithmetic, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to integers that are powers of 2 from 1 to 32 . For pitch class arithmetic, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to integers between 0 and 11.  \\ \\
\textbf{\emph{operator$_{comparison}$}} \\
For integer comparison, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to integers. For beat comparison, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to beats. \\ \\
\textbf{\emph{operator$_{boolean}$}} \\
For comparison, conjunction, and disjunction, \emph{expression$_{1}$} and \emph{expression$_{2}$} are variables or constants that evaluate to integers. \\ \\
\textbf{\emph{operator$_{list}$}} \\ \\
List operators require that  \emph{expression$_{2}$} is a list. When doing list construction,  \emph{expression$_{1}$} must be an element of the same type as the other elements in  \emph{expression$_{2}$}. When doing list concatenation,  \emph{expression$_{1}$} must be a list containing elements of the same type as  \emph{expression$_{2}$}. \\ \\
\textbf{\emph{operator$_{binding}$}} \\ \\
When doing type specification, \emph{expression$_{2}$} must be a type and \emph{expression$_{1}$} must be a non-keyword identifier. When doing argument and function return type specification, \emph{expression$_{1}$} and \emph{expression$_{2}$} must be types. When using case alternatives with guards,  \emph{expression$_{2}$} is a conditional expression and  \emph{expression$_{1}$} is either a conditional expression, indicating that there is more than one case for the guard, or a declaration. When doing assignment,  \emph{expression$_{1}$} is a non-keyword identifier and  \emph{expression$_{2}$} is an expression to bind to that identifier. \\ \\
\textbf{\emph{operator$_{negation}$}} \\ \\
For negation,  \emph{expression$_{1}$} is a comparison, conjunction, or disjunction expression.
    
\subsection{Conditionals}
  \texttt{if} \emph{expression$_{boolean}$} \texttt{then}  \emph{expression$_{true}$} \texttt{else}  \emph{expression$_{false}$} \\ \\
  When the value of \emph{expression$_{boolean}$} evaluates to true, \emph{expression$_{true}$} is evaluated, otherwise  \emph{expression$_{false}$} is evaluated. Conditional expressions do not have newline restrictions.

\subsection{Lists}
  \texttt{[} \emph{expression-list} \texttt{]} \\ \\
  where \\
  
  \emph{expression-list} $\rightarrow$  
  \emph{\textless empty \textgreater} $|$
  \emph{expression} (\texttt{,} \emph{expression})$*$  \\ \\
An example of how a list can be written is: \\

\texttt{[}\emph{expression$_{1}$}\texttt{,} \emph{...}\texttt{,} \emph{expression$_{k}$}\texttt{]} = 
  \emph{expression$_{1}$}\texttt{:(}\emph{expression$_{2}$}\texttt{:(} \emph{...} \texttt{(}\emph{expression$_{k}$}\texttt{:[ ]))} \\ \\
where \textit{k} \textgreater\space 0. The expressions in a list must all be of the same type. Both the list constructor \texttt{:} and empty list \texttt{[ ]} are reserved as part of the language syntax and therefore cannot be hidden or redefined. The list constructor has right associativity.

\subsection{Parenthesized Expressions}
  \texttt{(} \emph{expression} \texttt{)} \\ \\
  where \emph{expression} is evaluated as a primary expression. Parentheses are used to increase the precedence of an expression. For example 2 \texttt{+} 3 \texttt{*}  4  evaluates to 14 but \texttt{(} 2 \texttt{+} 3 \texttt{) *}  4 evaluates to 20. The parentheses force the addition operation to occur before the multiplication operation even though multiplication has higher precedence than addition in SMURF.

\subsection{Let Expressions}
\begin{grammar}
<let-exp> $\rightarrow$ let <decls> in <expression>
\end{grammar}
Let expressions have the form \emph{let \{} $d_1;...;d_n$ \} \emph{in e}, where $d_n$ is the nth declaration and \emph{e} is an expression. Note that the scope of $d_n$ is in \emph{e}.

% are pattern bindings matched lazily?

\subsection{Pattern Matching}

Patterns can be found in function definitions, pattern bindings, and list operations. Patterns are matched with values. Matching a pattern can either be successful or it can fail. A successful match will return  a binding for the variables in the pattern. 

\subsection{Guards}
\begin{grammar}
<guard> $\rightarrow$  let <decls> | <infixexp>          
\end{grammar}

There are two kinds of guards in SMURF: local bindings and boolean guards. Local bindings have the form let $<decls>$ and introduces the declarations to the program environment. Boolean guards are expressions of type Bool. The boolean guard succeeds if the expression evaluates to True.

