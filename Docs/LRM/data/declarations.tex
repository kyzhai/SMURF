\section{Declarations and Bindings}

This section of the LRM describes the syntax and informal semantics of
declarations in SMURF. A program in SMURF, at its top-most level, is a
series of declarations. However, declarations may also occur inside of
\texttt{let} expressions. The scoping of such declarations is described 
in this sections. There are three types of declarations in SMURF: 
type signatures, pattern declarations, and function declarations.

\subsection{Type Signatures}

\begin{grammar}

<type-sig> $\rightarrow$ <identifier> :: <type>

<type> $\rightarrow$ Int | Bool | Note | [<type>] | 
										( <type>, $\ldots$, <type> ) | <type> -> <type> | ( <type> )
										

\end{grammar}

A type signature explicitly defines a type for a given identifier. The
\texttt{::} operator can be read as ``has type of." Only one type signature
for a given identifier can exist in a given scope. That is, two different
type signatures for a given identifier can exist, but they must be declared
in different scopes. There are three categories of types in SMURF: primitive
types,  structured types, and type synonyms. By convention, type
names are identifiers starting with an uppercase letter.

\subsubsection{Primitive Types}

The three types \texttt{Int}, \texttt{Bool}, and \texttt{Note} are
the fundamental building blocks of the type system in SMURF. 

\subsubsection{Structured Types}

SMURF has three structured types: lists, tuples, and functions. Each
type is represented by a special syntactic construct that operates on
other types to generate a concrete structured result.

The list type is written as \texttt{[t]} which specifies the type of lists
containing elements of type t.

The tuple type is written as \texttt{$(t_1, t_2, \ldots, t_n)$} where $t_i$
can be any type. THis specifies the type of tuples of size $n$ whose first
element has type $t_1$ second element has type $t_2$, and so on. A tuple
type must have at least two elements.

The function type is written as \texttt[$t_1 -> t_2$] and specifies the type
of functions that take an argument of type $t_1$ and return a value of type
$t_2$. As with tuple types, $t_1$ and $t_2$ do not have to be the same.
The function arrow is right-associative, so \texttt[Int -> Bool -> Bool] is
equivalent semantically to \texttt[Int -> (Bool -> Int)]

\subsubsection{Type Synonyms}

Type synonyms give different names to specific types, making our language
more readable and less verbose.

The \texttt[Chord] type is equivalent to the \texttt[$[$Note$]$] type.

The \texttt[System] type is equivalent to the \texttt[$[$Chord$]$] type.

\subsection{Pattern Declarations}

\begin{grammar}

<identifier> $\rightarrow$ <expr> | <guards>

<guards> $\rightarrow$ $|$ <bool-expr> $=$ <expr> $\\n$ <guards> |
											 $|$	otherwise $=$ <expr>
\end{grammar}

\subsection{Function Declarations}

\subsection{\texttt{main} Declaration}
